import
  nat;

notation
  data [] ::;
  
  infix right 8 ::,
  infix right 7 ++;
end

defines
  list a == a :: [];
  list a b == a :: b :: [];

  [] ++ ys == ys;
  (x :: xs) ++ ys == x :: (xs ++ ys);

  map f [] == [];
  map f (x :: xs) == (f x) :: (map f xs);

  foldl f z [] == z;
  foldl f z (x :: xs) == foldl f (f z x) xs;

  unfoldl f (f y x) xs == unfoldl f y (x :: xs);
  unfoldl f z xs == (z, xs);

  foldr f z [] == z;
  foldr f z (x :: xs) == f x (foldr f z xs);
  
  unfoldr f (f x y) == x :: (unfoldr f y);
  unfoldr f z == z;

  flatten [] == [];
  flatten ([] :: ys) == flatten ys;
  flatten ((x :: xs) :: ys) == x :: flatten (xs :: ys);
  
  zip [] [] == [];
  zip (x :: xs) (y :: ys) == (x, y) :: zip xs ys;

  unzip [] == ([], []);
  unzip (x, y) :: zs
    == let (xs, ys) = unzip zs
       in (x :: xs, y :: ys);

  filter p [] == [];
  filter p (x :: xs)
    == let ys = (filter p xs)
       in if (p x) then (x :: ys) else ys;
  
  contains x [] == False;
  contains x (x :: xs) == True;
  contains x (y :: xs) == contains x xs;
       
  get _ [] == None;
  get 0      (x :: xs) == Some x;
  get (n +1) (x :: xs) == get n xs;

  index x [] == None;
  index x (x :: xs) == Some 0;
  index x (y :: xs) == index x xs +1;
end

eval
  map (+1) [0 1 2];
end
