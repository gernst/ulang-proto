notation
  data [] ::;
  
  infix right 8 ::,
  infix right 7 ++;
end

pattern
  [] == Nil;
  x :: xs == Cons x xs;
end

define
  []: List a == True;
  x :: xs: List a == x: a and xs: List a;
  _: List a == False;
end

define
  list None == [];
  list (Some x) == [x];
  
  head (x :: xs) == x;
  tail (x :: xs) == xs;
  
  take 0 xs == [];
  take (n +1) (x :: xs) == x :: take n xs;

  [] ++ ys == ys;
  (x :: xs) ++ ys == x :: (xs ++ ys);

  map f [] == [];
  map f (x :: xs) == (f x) :: (map f xs);
  
  collect f [] == [];
  collect f (x :: xs)
    == list (f x) ++ collect f xs;

  foldl f z [] == z;
  foldl f z (x :: xs) == foldl f (f z x) xs;

  unfoldl f (f y x) xs == unfoldl f y (x :: xs);
  unfoldl f z xs == (z, xs);

  foldr f z [] == z;
  foldr f z (x :: xs) == f x (foldr f z xs);
  
  unfoldr f (f x y) == x :: (unfoldr f y);
  unfoldr f z == z;

  flatten [] == [];
  flatten ([] :: ys) == flatten ys;
  flatten ((x :: xs) :: ys) == x :: flatten (xs :: ys);
  
  zip [] [] == [];
  zip (x :: xs) (y :: ys) == (x, y) :: zip xs ys;

  unzip [] == ([], []);
  unzip (x, y) :: zs
    == let (xs, ys) = unzip zs
       in (x :: xs, y :: ys);

  filter p [] == [];
  
  /* needs specific pattern grammar
  filter p (x :: xs) if (p x)
    == x :: filter p xs;
  filter p (_ :: xs)
    == filter p xs;
   */
  
  filter p (x :: xs)
    == let ys = (filter p xs)
       in if (p x) then (x :: ys) else ys;
  
  contains x [] == False;
  contains x (x :: xs) == True;
  contains x (y :: xs) == contains x xs;
       
  get _ [] == None;
  get 0      (x :: xs) == Some x;
  get (n +1) (x :: xs) == get n xs;

  index x [] == None;
  index x (x :: xs) == Some 0;
  index x (y :: xs) == index x xs +1;
  
  lookup _ [] == None;
  lookup x ((x,y) :: xs) == Some y;
  lookup x (_ :: xs) == lookup x xs;

  store x z xs
    == (x,z) :: xs;
end

test
  [0 1 2] ++ [3 4] == [0 1 2 3 4]; 
  map (+1) [0 1 2 3] == [1 2 3 4];
  filter even [0 1 2 3 4] == [0 2 4];
  
  [0 1 2 3 4]: List Nat == True;
  [A]: List Nat == False;
end
