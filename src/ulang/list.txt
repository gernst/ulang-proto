definitions

[] ++ ys == ys;
(x :: xs) ++ ys == x :: (xs ++ ys);

map f [] == [];
map f (x :: xs) == (f x) :: (map f xs);

foldl f z [] == z;
foldl f z (x :: xs) == foldl f (f z x) xs;

unfoldl f (f y x) xs == unfoldl f y (x :: xs);
unfoldl f z xs == (z, xs);

foldr f z [] == z;
foldr f z (x :: xs) == f x (foldr f z xs);

zip [] [] == [];
zip (x :: xs) (y :: ys) == (x, y) :: zip xs ys;

unzip [] == [];
unzip (x, y) :: zs
  == let (xs, ys) = unzip zs
     in (x :: xs, y :: ys);

filter p [] == [];
filter p (x :: xs)
  == let ys = (filter p xs)
     in if (p x) then (x :: ys) else ys;

end