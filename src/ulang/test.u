import base;

grammar
  xy = "x" { X } | "y" { Y };
  foo = xy * ";";
end

language
  foo;

foo
  y x x y;
end

/*

define
  test p@(x,y) = p;
  test l@(x :: y) = l;
end

eval
  flatten [[A, B], [C, D]];
  flatten (Some (Some A));
  
  test (1,2);
  test (A :: []);
  
  let x = X in let y = Y in
  let x = y, y = x in (x, y);
  
  try raise A, B
  catch A, C -> C | _, B -> D;
  
  $ x;
  let z = $ X
  in [z, (force z), z];
  
  flatmap (\x -> [X, x]) [A, B, C];
  collect (\x -> if x = B then None else Some x) [A, B, C];
  /* [ if x = B then None else Some x
     | x <- [A, B, C]
     ] */

  ` x;
  ` f x;  
  
  "hello";
  'x';
   ` (=>);
end
*/
/*
lemma
  assume n: Nat and m: Nat;
  show n + m : Nat;
  show n + m = m + n;
end
*/