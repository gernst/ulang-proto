import
  nat list;

definitions
  debruijn (Const z) stack
    == Const z;

  debruijn (Var x) stack
    == match (index x stack) with
         | Some i -> Var i;
  
  debruijn (Let x b) stack
    == Let (debruijn b (x :: stack));

  debruijn (App f a) stack
    == App (debruijn f stack) (debruijn a stack);
  
  debruijn (Lambda x b) stack
    == Lambda (debruijn b (x :: stack));
    
    
  beta (Const z)
    == Const z;

  beta (Var i)
    == (Var i);
    
  beta (App (Lambda b) a)
    == Let (beta a) (beta b);
  
  beta (App f a)
    == App (beta f) (beta a);
    
  beta (Lambda b)
    == Lambda (beta b);
    
    
  compile (Const z)
    == list (Const z);
  
  compile (Var i)
    == list (Get i);
    
  compile (Let a b)
    == compile a ++ list Store ++ compile b;

  compile (App f a)
    == compile a ++ compile f ++ list Apply;
    
  compile (Lambda b)
    == list (Close (compile b ++ list Return));
  
    
  exec [] env (x :: stack)
    == x;
  
  exec (Const x :: code) env stack
    == exec code env (x :: stack);
    
  exec (Store :: code) env (x :: stack)
    == exec code (x :: env) stack;
    
  exec (Get i :: code) env stack
    == match (get i env) with
       | Some x -> exec code env (x :: stack);

  exec (Close c :: code) env stack
    == exec code env (Closure c env :: stack);
    
  exec (Apply :: code) env (Closure c e :: x :: stack)
    == exec c (x :: e) (Cont code env :: stack);
    
  exec (Return :: _) env (x :: Cont c e :: stack)
    == exec c e (x :: stack);
  
  ulang e == compile (beta (debruijn e []));
  
  prog == (App (Lambda X (Var X)) (Const Y)); 
end

eval
  let code = print (ulang prog)
  in exec code [] [];
end